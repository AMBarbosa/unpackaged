quantumBiodiv <- function(models = NULL, # list of model objects
                          data = NULL,   # alternatively, data frame with observations and predictions
                          sp.cols = NULL,  # index numbers of columns with obs data
                          prob.cols = NULL,  # index numbers of columns with probabilities
                          fav.cols = NULL,  # alternatively, index numbers of columns with favourabilities
                          id.col = NULL,  # optionally, index number of column with row identifiers
                          na.rm = TRUE) {

  # version 1.0 (12 Aug 2015)
  
  if (!is.null(models)) {
    obs.data <- as.data.frame(lapply(models, `[[`, "y"))
    prob.data <- as.data.frame(lapply(models, `[[`, "fitted.values"))
  } else {
    obs.data <- data[ , sp.cols, drop = FALSE]
    if (!is.null(prob.cols))  prob.data <- data[ , prob.cols, drop = FALSE]
  }   # end if !null models else
  
  Nobs <- nrow(obs.data)
  Nsp <- ncol(obs.data)

  if (is.null(fav.cols)) {
    require(fuzzySim)  # fuzzysim.r-forge.r-project.org
    favs <- matrix(NA, ncol = Nsp, nrow = Nobs)
    for (s in 1:Nsp) {
      favs[ , s] <- Fav(obs = obs.data[ , s], pred = prob.data[ , s])
    }; rm(s)
  } else {  # if !null fav.cols
    favs <- data[ , fav.cols, drop = FALSE]
  }  # end if null fav else
  
  fav_lns <- log(favs, base = exp(1))
  F_ln_sum <- rowSums(fav_lns, na.rm = na.rm)
  
  result <- data.frame(matrix(NA, ncol = 6, nrow = Nobs))
  colnames(result) <- c("Sp_rich", "F_min", "F_max", "F_sum", "F_arith_mn", "F_geom_mn")
  result$Sp_rich <- rowSums(obs.data, na.rm = na.rm)
  result$F_min <- apply(favs, 1, min, na.rm = na.rm)
  result$F_max <- apply(favs, 1, max, na.rm = na.rm)
  result$F_sum <- rowSums(favs, na.rm = na.rm)
  result$F_arith_mn <- rowMeans(favs, na.rm = na.rm)
  result$F_geom_mn <- vector("numeric", Nobs)
  for (i in 1:Nobs) result$F_geom_mn[i] <- exp((1 / Nsp) * F_ln_sum[i])
  
  if (!is.null(data) & !is.null(id.col))
    result <- data.frame(data[ , id.col, drop = FALSE], result)
  
  return(result)
}
